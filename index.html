<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Standard favicon -->
    <link rel="icon" href="/favicon.ico" sizes="any">
    <!-- For modern browsers (PNG, SVG are preferred) -->
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon-192x192.png">
    <!-- For Apple devices -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <head>
    <title>RBMK-1000 Performance Console - Continuous Ops</title>
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --cyan: #58a6ff;
            --red: #f85149;
            --yellow: #d29922;
            --green: #3fb950;
            --border: #30363d;
            --incandescent: #ffcc00; /* Warm industrial yellow */
        }

        html, body {
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            background-color: var(--bg);
            color: #c9d1d9;
            font-family: 'Consolas', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        header {
            height: 80px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            padding: 10px 20px;
            background: var(--panel);
            border-bottom: 2px solid var(--border);
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .stat-card {
            background: #0d1117;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .stat-label { font-size: 10px; color: #8b949e; text-transform: uppercase; margin-bottom: 2px; }
        .stat-value { font-size: 20px; font-weight: bold; }

        main {
            flex-grow: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #sidebar {
            width: 320px;
            background: var(--panel);
            border-right: 2px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 12px;
            box-sizing: border-box;
            flex-shrink: 0;
            gap: 15px;
        }

        .side-module {
            background: #000;
            border: 1px solid var(--border);
            position: relative;
        }

        #caps-box { height: 260px; display: flex; justify-content: center; align-items: center; }
        #graph-box { flex-grow: 1; }

        #viewport {
            flex-grow: 1;
            background: #050505;
            position: relative;
        }

        #coreCanvas { position: absolute; top: 0; left: 0; }

        footer {
            height: 100px;
            background: var(--panel);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            border-top: 2px solid var(--border);
            flex-shrink: 0;
        }

        .ctrl-grp { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .ctrl-grp label { font-size: 9px; color: #8b949e; }
        input[type=range] { width: 130px; accent-color: var(--cyan); }

        button {
            padding: 10px 15px; border-radius: 4px; border: 1px solid var(--border);
            background: #21262d; color: white; cursor: pointer; font-weight: bold; font-size: 11px;
        }
        button.active { background: var(--green); }
        #az5-btn { background: #8e1515; border-color: var(--red); }

        #meltdown-overlay {
            position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(142, 21, 21, 0.9);
            color: white; border: 4px solid var(--red);
            padding: 20px 40px; text-align: center;
            display: none; z-index: 1000; pointer-events: none;
        }

        .legend {
            font-size: 9px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>

<header>
    <div class="stat-card">
        <div class="stat-label">Reactor Power</div>
        <div id="ui-mw" class="stat-value">0 MWt</div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Flux (Reactivity)</div>
        <div id="ui-react" class="stat-value" style="color: var(--cyan)">0</div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Radioactivity</div>
        <div id="ui-radio" class="stat-value" style="color: var(--red)">0 mR/h</div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Core Stability</div>
        <div id="ui-void" class="stat-value">100%</div>
    </div>
</header>

<main>
    <div id="sidebar">
        <div class="stat-label">Upper Bio-Shield Caps</div>
        <div id="caps-box" class="side-module">
            <canvas id="capsCanvas"></canvas>
        </div>

        <div class="stat-label">System Telemetry</div>
        <div class="legend">
            <span><span style="color:var(--cyan)">●</span> FLUX</span>
            <span><span style="color:var(--yellow)">●</span> POWER</span>
            <span><span style="color:var(--red)">●</span> RAD</span>
        </div>
        <div id="graph-box" class="side-module">
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>
    <div id="viewport">
        <canvas id="coreCanvas"></canvas>
    </div>
</main>

<div id="meltdown-overlay">
    <h1 style="margin: 0;">!!! MELTDOWN !!!</h1>
    <p>PROMPT CRITICALITY REACHED</p>
</div>

<footer>
    <div class="ctrl-grp">
        <label>BORON RODS</label>
        <input type="range" id="rodSlid" min="0" max="100" value="80">
    </div>
    <div class="ctrl-grp">
        <label>MODERATOR BANK</label>
        <input type="range" id="modSlid" min="0" max="100" value="50">
    </div>
    <button id="autoToggle">AUTO: OFF</button>
    <button id="az5-btn">AZ-5 SCRAM</button>
    <button onclick="location.reload()" style="background: #333;">RESET</button>
</footer>

<script>
    const canvas = document.getElementById('coreCanvas');
    const ctx = canvas.getContext('2d');
    const gCanvas = document.getElementById('graphCanvas');
    const gCtx = gCanvas.getContext('2d');
    const cCanvas = document.getElementById('capsCanvas');
    const cCtx = cCanvas.getContext('2d');

    const CELL_SIZE = 16;
    let COLS, ROWS, grid = [];
    let particles = [];
    let rodPos = 80, modPos = 50, radioactivity = 0;
    let isAuto = false, isScram = false;
    let history = [];
    let avgTemp = 20;

    function resize() {
        const vp = document.getElementById('viewport');
        canvas.width = vp.clientWidth; canvas.height = vp.clientHeight;
        const gb = document.getElementById('graph-box');
        gCanvas.width = gb.clientWidth; gCanvas.height = gb.clientHeight;
        const cb = document.getElementById('caps-box');
        cCanvas.width = cb.clientWidth; cCanvas.height = cb.clientHeight;
        
        COLS = Math.floor(canvas.width / CELL_SIZE);
        ROWS = Math.floor(canvas.height / CELL_SIZE);
        initGrid();
    }

    function initGrid() {
        grid = [];
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                let type = 'water';
                if (c % 2 === 0 && r % 3 === 0) type = 'fuel';
                else if (c % 4 === 1) type = 'mod-ch';
                else if (c % 4 === 3) type = 'rod-ch';
                grid.push({ x: c*CELL_SIZE, y: r*CELL_SIZE, col: c, row: r, type, temp: 20 });
            }
        }
    }

    function spawn(x, y, fast) {
        if (particles.length > 1500) return;
        particles.push({ x, y, fast, vx: (Math.random()-0.5)*(fast?6:2.5), vy: (Math.random()-0.5)*(fast?6:2.5), life: 0 });
    }

    function update() {
        if (isAuto && !isScram) {
            if (particles.length > 155) { rodPos += 0.2; modPos -= 0.1; }
            else if (particles.length < 145) { rodPos -= 0.2; modPos += 0.1; }
            rodPos = Math.max(0, Math.min(100, rodPos));
            modPos = Math.max(0, Math.min(100, modPos));
            document.getElementById('rodSlid').value = rodPos;
            document.getElementById('modSlid').value = modPos;
        }

        if (isScram) {
            rodPos += 0.4;
            if (rodPos >= 100) { rodPos = 100; isScram = false; }
            document.getElementById('rodSlid').value = rodPos;
        }

        if (Math.random() > 0.8) spawn(Math.random()*canvas.width, Math.random()*canvas.height, false);

        let totalTemp = 0;
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i]; p.x += p.vx; p.y += p.vy; p.life++;
            if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) { particles.splice(i, 1); continue; }

            const gx = (p.x/CELL_SIZE)|0; const gy = (p.y/CELL_SIZE)|0;
            const cell = grid[gy * COLS + gx];
            if (cell) {
                // Boron rod absorption
                if (cell.type === 'rod-ch' && p.y < (canvas.height * rodPos / 100)) { 
                    particles.splice(i, 1); continue; 
                }
                // Moderator bank thermalization
                if (cell.type === 'mod-ch' && p.y < (canvas.height * modPos / 100) && p.fast) {
                    if (Math.random() > 0.4) { p.fast = false; p.vx *= 0.5; p.vy *= 0.5; }
                }
                // Fission
                if (cell.type === 'fuel' && !p.fast && Math.random() < 0.68) {
                    particles.splice(i, 1); radioactivity += 2.5; cell.temp += 15;
                    const nYield = Math.random() > 0.5 ? 3 : 4;
                    for(let n=0; n<nYield; n++) spawn(p.x, p.y, true);
                    continue;
                }
            }
            if (p.life > 350) particles.splice(i, 1);
        }

        let boiling = 0;
        grid.forEach(c => {
            if (c.temp > 20) c.temp -= 0.3;
            if (c.temp > 100) boiling++;
            totalTemp += c.temp;
        });
        avgTemp = totalTemp / grid.length;

        if (particles.length > 300) document.getElementById('meltdown-overlay').style.display = 'block';
        else document.getElementById('meltdown-overlay').style.display = 'none';

        if (timer++ % 10 === 0) {
            history.push({ r: particles.length, p: particles.length * 50, rad: radioactivity });
            if (history.length > 100) history.shift();
        }
        radioactivity *= 0.99;
        document.getElementById('ui-mw').innerText = Math.floor(particles.length * 50) + " MWt";
        document.getElementById('ui-react').innerText = particles.length;
        document.getElementById('ui-radio').innerText = Math.floor(radioactivity) + " mR/h";
        document.getElementById('ui-void').innerText = (100 - Math.floor((boiling/grid.length)*100)) + "%";
    }

    let timer = 0;

    function drawCaps() {
        cCtx.fillStyle = '#050505';
        cCtx.fillRect(0,0,cCanvas.width, cCanvas.height);
        
        const centerX = cCanvas.width / 2;
        const centerY = cCanvas.height / 2;
        const radius = Math.min(centerX, centerY) * 0.92;
        const spacing = 10;
        const capSize = 9;

        for (let x = -radius; x < radius; x += spacing) {
            for (let y = -radius; y < radius; y += spacing) {
                const dist = Math.sqrt(x*x + y*y);
                if (dist < radius) {
                    const drawX = centerX + x;
                    const drawY = centerY + y;

                    // Localized heat mapping
                    const noise = Math.sin(x*0.05 + timer*0.08) * Math.cos(y*0.05 + timer*0.08);
                    const heat = (particles.length / 300) * 100 + (noise * 60);

                    let offsetX = 0, offsetY = 0;
                    if (heat > 130) {
                        offsetX = (Math.random() - 0.5) * (heat / 40);
                        offsetY = (Math.random() - 0.5) * (heat / 40);
                    }

                    // Metal plate
                    cCtx.fillStyle = '#2a2a2a';
                    cCtx.fillRect(drawX + offsetX, drawY + offsetY, capSize, capSize);

                    // Industrial Yellow Glow (Incandescent)
                    if (heat > 90) {
                        const alpha = Math.min(1, (heat - 90) / 100);
                        cCtx.fillStyle = `rgba(255, 204, 0, ${alpha})`;
                        cCtx.fillRect(drawX + offsetX + 1, drawY + offsetY + 1, capSize - 2, capSize - 2);
                        
                        // Bright center for high intensity
                        if (heat > 160) {
                            cCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                            cCtx.fillRect(drawX + offsetX + 3, drawY + offsetY + 3, capSize - 6, capSize - 6);
                        }
                    }
                }
            }
        }
    }

    function drawGraph() {
        gCtx.fillStyle = '#050505';
        gCtx.fillRect(0,0,gCanvas.width, gCanvas.height);
        
        // Axis lines & labels
        gCtx.strokeStyle = '#222';
        gCtx.font = "8px Arial";
        gCtx.fillStyle = "#666";
        for(let i=0; i<=4; i++) {
            let y = gCanvas.height - (i * gCanvas.height / 4);
            gCtx.beginPath(); gCtx.moveTo(25, y); gCtx.lineTo(gCanvas.width, y); gCtx.stroke();
            gCtx.fillText(i*100, 2, y + 3);
        }

        // Limit Line (Red dashed)
        const limitY = gCanvas.height - (300/400) * gCanvas.height;
        gCtx.strokeStyle = 'rgba(255,0,0,0.4)';
        gCtx.setLineDash([4, 4]);
        gCtx.beginPath(); gCtx.moveTo(25, limitY); gCtx.lineTo(gCanvas.width, limitY); gCtx.stroke();
        gCtx.setLineDash([]);

        if (history.length < 2) return;
        const plot = (prop, color, max) => {
            gCtx.strokeStyle = color; gCtx.lineWidth = 2; gCtx.beginPath();
            history.forEach((pt, i) => {
                const x = 25 + (i / (history.length-1)) * (gCanvas.width - 25);
                const y = gCanvas.height - (pt[prop]/max) * gCanvas.height;
                if(i===0) gCtx.moveTo(x,y); else gCtx.lineTo(x,y);
            });
            gCtx.stroke();
        };
        plot('r', '#58a6ff', 400);   // Flux
        plot('p', '#d29922', 20000); // MWt
        plot('rad', '#f85149', 1500); // Radioactivity
    }

    function drawCore() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        grid.forEach(c => {
            if (c.type === 'fuel') {
                ctx.fillStyle = '#1e3a1e'; ctx.fillRect(c.x, c.y, CELL_SIZE, CELL_SIZE);
                ctx.fillStyle = c.temp > 140 ? '#ffcc00' : '#3fb950';
                ctx.beginPath(); ctx.arc(c.x+8, c.y+8, 3, 0, 7); ctx.fill();
            }
            if (c.type === 'mod-ch') {
                ctx.fillStyle = 'rgba(88, 166, 255, 0.15)'; ctx.fillRect(c.x, c.y, CELL_SIZE, CELL_SIZE);
            }
        });

        const rh = (canvas.height * rodPos)/100;
        const mh = (canvas.height * modPos)/100;

        for(let c=0; c<COLS; c++) {
            // Control Rods
            if (c % 4 === 3) {
                ctx.fillStyle = '#444'; ctx.fillRect(c*CELL_SIZE+5, 0, CELL_SIZE-10, rh);
                ctx.fillStyle = '#fff'; ctx.fillRect(c*CELL_SIZE+5, rh, CELL_SIZE-10, 5); 
            }
            // Moderator Bank (Graphite Displacers)
            if (c % 4 === 1) {
                ctx.fillStyle = 'rgba(150, 200, 255, 0.4)'; ctx.fillRect(c*CELL_SIZE+6, 0, CELL_SIZE-12, mh);
            }
        }

        particles.forEach(p => {
            ctx.fillStyle = p.fast ? '#fff' : '#aaa';
            ctx.fillRect(p.x, p.y, 2, 2);
        });
    }

    function loop() {
        update();
        drawCore();
        drawGraph();
        drawCaps();
        requestAnimationFrame(loop);
    }

    window.addEventListener('resize', resize);
    document.getElementById('rodSlid').oninput = (e) => { if(!isAuto) rodPos = +e.target.value; };
    document.getElementById('modSlid').oninput = (e) => { if(!isAuto) modPos = +e.target.value; };
    document.getElementById('autoToggle').onclick = (e) => {
        isAuto = !isAuto; e.target.classList.toggle('active');
        e.target.innerText = isAuto ? "AUTO: ON" : "AUTO: OFF";
    };
    document.getElementById('az5-btn').onclick = () => {
        isScram = true; isAuto = false;
        if(rodPos < 45) { // Fatal graphite tip displacement
            for(let i=0; i<250; i++) spawn(Math.random()*canvas.width, (canvas.height*rodPos/100)+5, false);
        }
    };

    resize();
    loop();
</script>
</body>
</html>
